% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/heatmap.R
\name{anno_pie}
\alias{anno_pie}
\alias{anno_ring}
\alias{anno_bar}
\alias{anno_violin}
\alias{anno_boxplot}
\alias{anno_density}
\alias{anno_simple}
\alias{anno_points}
\alias{anno_lines}
\alias{Heatmap}
\title{Heatmap annotations supported by \code{plotthis}}
\usage{
anno_pie(
  x,
  split_by = NULL,
  group_by,
  column,
  title,
  which = "row",
  palette,
  palcolor = NULL,
  border = TRUE,
  legend.direction,
  show_legend = TRUE,
  ...
)

anno_ring(
  x,
  split_by = NULL,
  group_by,
  column,
  title,
  which = "row",
  palette,
  palcolor = NULL,
  border = TRUE,
  legend.direction,
  show_legend = TRUE,
  ...
)

anno_bar(
  x,
  split_by = NULL,
  group_by,
  column,
  title,
  which = "row",
  palette,
  palcolor = NULL,
  border = TRUE,
  legend.direction,
  show_legend = TRUE,
  ...
)

anno_violin(
  x,
  split_by = NULL,
  group_by,
  column,
  title,
  which = "row",
  palette,
  palcolor = NULL,
  border = TRUE,
  legend.direction,
  show_legend = TRUE,
  ...
)

anno_boxplot(
  x,
  split_by = NULL,
  group_by,
  column,
  title,
  which = "row",
  palette,
  palcolor = NULL,
  border = TRUE,
  legend.direction,
  show_legend = TRUE,
  ...
)

anno_density(
  x,
  split_by = NULL,
  group_by,
  column,
  title,
  which = "row",
  palette,
  palcolor = NULL,
  border = TRUE,
  legend.direction,
  show_legend = TRUE,
  ...
)

anno_simple(
  x,
  split_by = NULL,
  group_by,
  column,
  title,
  which = "row",
  palette,
  palcolor = NULL,
  border = TRUE,
  legend.direction,
  show_legend = TRUE,
  alpha = 1,
  ...
)

anno_points(
  x,
  split_by = NULL,
  group_by,
  column,
  title,
  which = "row",
  palette,
  palcolor = NULL,
  border = TRUE,
  legend.direction,
  show_legend = TRUE,
  alpha = 1,
  ...
)

anno_lines(
  x,
  split_by = NULL,
  group_by,
  column,
  title,
  which = "row",
  palette,
  palcolor = NULL,
  border = TRUE,
  legend.direction,
  show_legend = TRUE,
  alpha = 1,
  add_points = TRUE,
  ...
)

Heatmap(
  data,
  rows,
  columns_by,
  split_by = NULL,
  split_by_sep = "_",
  split_rows_data = FALSE,
  name = "value",
  border = TRUE,
  rows_palette = "Paired",
  rows_palcolor = NULL,
  columns_by_sep = "_",
  columns_split_by = NULL,
  columns_palette = "Paired",
  columns_palcolor = NULL,
  columns_split_by_sep = "_",
  columns_split_palette = "simspec",
  columns_split_palcolor = NULL,
  rows_data = NULL,
  rows_split_by = NULL,
  rows_split_by_sep = "_",
  rows_split_palette = "simspec",
  rows_split_palcolor = NULL,
  cluster_columns = TRUE,
  cluster_rows = TRUE,
  show_row_names = FALSE,
  show_column_names = FALSE,
  column_title = character(0),
  row_title = character(0),
  na_col = "grey85",
  limits = NULL,
  row_names_side = "right",
  column_names_side = "bottom",
  bars_sample = 100,
  flip = FALSE,
  label_size = 10,
  label_cutoff = NULL,
  label_accuracy = 0.01,
  layer_fun_callback = NULL,
  cell_type = c("tile", "bars", "label", "dot", "violin", "boxplot"),
  cell_agg = mean,
  add_bg = FALSE,
  bg_alpha = 0.5,
  violin_fill = NULL,
  boxplot_fill = NULL,
  dot_size = 8,
  dot_size_name = "size",
  column_annotation = NULL,
  column_annotation_side = "top",
  column_annotation_palette = "Paired",
  column_annotation_palcolor = NULL,
  column_annotation_type = "auto",
  column_annotation_params = list(),
  column_annotation_agg = NULL,
  row_annotation = NULL,
  row_annotation_side = "left",
  row_annotation_palette = "Paired",
  row_annotation_palcolor = NULL,
  row_annotation_type = "auto",
  row_annotation_params = list(),
  row_annotation_agg = NULL,
  add_reticle = FALSE,
  reticle_color = "grey",
  palette = "RdBu",
  palcolor = NULL,
  alpha = 1,
  legend.position = "right",
  legend.direction = "vertical",
  seed = 8525,
  combine = TRUE,
  nrow = NULL,
  ncol = NULL,
  byrow = TRUE,
  ...
)
}
\arguments{
\item{x}{A data frame}

\item{split_by}{A character string of the column name to split the data (heatmap)}

\item{group_by}{A character string of the column name to group the data (rows or columns of the heatmap)}

\item{column}{A character string of the column name of the data \code{x} to plot}

\item{title}{A character string to name the legend}

\item{which}{A character string specifying the direction of the annotation. Default is "row".
Other options are "column".}

\item{palette}{A character string specifying the palette of the annotation}

\item{palcolor}{A character vector of colors to override the palette}

\item{border}{A logical value indicating whether to draw the border of the annotation}

\item{legend.direction}{A character string specifying the direction of the legend. Default is "vertical".
Other options are "horizontal".}

\item{show_legend}{A logical value indicating whether to show the legend}

\item{...}{Other arguments passed to \code{ComplexHeatmap::AnnotationFunction}
The parameters passed to \code{row_annotation_params} and \code{column_annotation_params} will be passed here.}

\item{alpha}{A numeric value between 0 and 1 specifying the transparency of the annotation}

\item{add_points}{A logical value indicating whether to add points to the annotation}

\item{data}{A data frame.}

\item{rows}{A character string/vector of the column name(s) to plot for the rows
Multiple columns in the data frame can be used as the rows.}

\item{columns_by}{A character string of the column name to plot for the columns
A character/factor column is expected.}

\item{split_by_sep}{The separator for multiple split_by columns. See \code{\link{split_by}}}

\item{split_rows_data}{A logical value indicating whether to split the rows data as well using 'split_by' and 'split_by_sep'.}

\item{name}{A character string specifying the name of the main legend of the heatmap}

\item{rows_palette}{A character string specifying the palette of the row group annotation.
The default is "Paired".}

\item{rows_palcolor}{A character vector of colors to override the palette of the row group annotation.}

\item{columns_by_sep}{A character string to concatenate the columns in \code{columns_by} if there are multiple columns.}

\item{columns_split_by}{A character string of the column name to split the heatmap columns into slices.
A character/factor column or multiple columns are expected.}

\item{columns_palette}{A character string specifying the palette of the column group annotation.
The default is "Paired".}

\item{columns_palcolor}{A character vector of colors to override the palette of the column group annotation.}

\item{columns_split_by_sep}{A character string to concatenate the columns in \code{columns_split_by} if there are multiple columns.}

\item{columns_split_palette}{A character string specifying the palette of the column split annotation.
The default is "simspec".}

\item{columns_split_palcolor}{A character vector of colors to override the palette of the column split annotation.}

\item{rows_data}{A character string of the column name to use as the data for the row group annotation.
If it starts with "@", it will be treated as an attribute of the data.}

\item{rows_split_by}{A character string of the column name to split the heatmap rows into slices.
A character/factor column or multiple columns are expected.}

\item{rows_split_by_sep}{A character string to concatenate the columns in \code{rows_split_by} if there are multiple columns.}

\item{rows_split_palette}{A character string specifying the palette of the row split annotation.
The default is "simspec".}

\item{rows_split_palcolor}{A character vector of colors to override the palette of the row split annotation.}

\item{cluster_columns}{A logical value indicating whether to cluster the columns.
If TRUE and columns_split_by is provided, the clustering will only be applied to the columns within the same split.}

\item{cluster_rows}{A logical value indicating whether to cluster the rows.
If TRUE and rows_split_by is provided, the clustering will only be applied to the rows within the same split.}

\item{show_row_names}{A logical value indicating whether to show the row names.
If TRUE, the legend of the row group annotation will be hidden.}

\item{show_column_names}{A logical value indicating whether to show the column names.
If TRUE, the legend of the column group annotation will be hidden.}

\item{column_title}{A character string/vector of the column name(s) to use as the title of the column group annotation.}

\item{row_title}{A character string/vector of the column name(s) to use as the title of the row group annotation.}

\item{na_col}{A character string specifying the color for missing values.
The default is "grey85".}

\item{limits}{A numeric vector of length 2 specifying the the values in the heatmap.
If NULL, the limits will be calculated from the data, which is the 1st and 99th quantile.}

\item{row_names_side}{A character string specifying the side of the row names.
The default is "right".}

\item{column_names_side}{A character string specifying the side of the column names.
The default is "bottom".}

\item{bars_sample}{An integer specifying the number of samples to draw the bars.}

\item{flip}{A logical value indicating whether to flip the heatmap.}

\item{label_size}{A numeric value specifying the size of the labels when \code{cell_type = "label"}.}

\item{label_cutoff}{A numeric value specifying the cutoff to show the labels when \code{cell_type = "label"}.}

\item{label_accuracy}{A numeric value specifying the accuracy of the labels when \code{cell_type = "label"}.}

\item{layer_fun_callback}{A function to add additional layers to the heatmap.
The function should have the following arguments: \code{j}, \code{i}, \code{x}, \code{y}, \code{w}, \code{h}, \code{fill}, \code{sr} and \code{sc}.
Please also refer to the \code{layer_fun} argument in \code{ComplexHeatmap::Heatmap}.}

\item{cell_type}{A character string specifying the type of the heatmap cells.
The default is "tile". Other options are "bars", "label", "dot", "violin", "boxplot".}

\item{cell_agg}{A function to aggregate the values in the cell, for the cell type "tile" and "label".
The default is \code{mean}.}

\item{add_bg}{A logical value indicating whether to add a background to the heatmap.
Does not work with \code{cell_type = "bars"} or \code{cell_type = "tile"}.}

\item{bg_alpha}{A numeric value between 0 and 1 specifying the transparency of the background.}

\item{violin_fill}{A character vector of colors to override the fill color of the violin plot.
If NULL, the fill color will be the same as the annotion.}

\item{boxplot_fill}{A character vector of colors to override the fill color of the boxplot.
If NULL, the fill color will be the same as the annotion.}

\item{dot_size}{A numeric value specifying the size of the dot or a function to calculate the size
from the values in the cell.}

\item{dot_size_name}{A character string specifying the name of the legend for the dot size.}

\item{column_annotation}{A character string/vector of the column name(s) to use as the column annotation.
Or a list with the keys as the names of the annotation and the values as the column names.}

\item{column_annotation_side}{A character string specifying the side of the column annotation.
Could be a list with the keys as the names of the annotation and the values as the sides.}

\item{column_annotation_palette}{A character string specifying the palette of the column annotation.
The default is "Paired".
Could be a list with the keys as the names of the annotation and the values as the palettes.}

\item{column_annotation_palcolor}{A character vector of colors to override the palette of the column annotation.
Could be a list with the keys as the names of the annotation and the values as the palcolors.}

\item{column_annotation_type}{A character string specifying the type of the column annotation.
The default is "auto". Other options are "simple", "pie", "ring", "bar", "violin", "boxplot", "density".
Could be a list with the keys as the names of the annotation and the values as the types.
If the type is "auto", the type will be determined by the type and number of the column data.}

\item{column_annotation_params}{A list of parameters passed to the annotation function.
Could be a list with the keys as the names of the annotation and the values as the parameters.}

\item{column_annotation_agg}{A function to aggregate the values in the column annotation.}

\item{row_annotation}{A character string/vector of the column name(s) to use as the row annotation.
Or a list with the keys as the names of the annotation and the values as the column names.}

\item{row_annotation_side}{A character string specifying the side of the row annotation.
Could be a list with the keys as the names of the annotation and the values as the sides.}

\item{row_annotation_palette}{A character string specifying the palette of the row annotation.
The default is "Paired".
Could be a list with the keys as the names of the annotation and the values as the palettes.}

\item{row_annotation_palcolor}{A character vector of colors to override the palette of the row annotation.
Could be a list with the keys as the names of the annotation and the values as the palcolors.}

\item{row_annotation_type}{A character string specifying the type of the row annotation.
The default is "auto". Other options are "simple", "pie", "ring", "bar", "violin", "boxplot", "density".
Could be a list with the keys as the names of the annotation and the values as the types.
If the type is "auto", the type will be determined by the type and number of the row data.}

\item{row_annotation_params}{A list of parameters passed to the annotation function.
Could be a list with the keys as the names of the annotation and the values as the parameters.}

\item{row_annotation_agg}{A function to aggregate the values in the row annotation.}

\item{add_reticle}{A logical value indicating whether to add a reticle to the heatmap.}

\item{reticle_color}{A character string specifying the color of the reticle.}

\item{legend.position}{A character string specifying the position of the legend.}

\item{seed}{The random seed to use. Default is 8525.}

\item{combine}{Whether to combine the plots into one when facet is FALSE. Default is TRUE.}

\item{nrow}{A numeric value specifying the number of rows in the facet.}

\item{ncol}{A numeric value specifying the number of columns in the facet.}

\item{byrow}{A logical value indicating whether to fill the plots by row.}
}
\description{
\verb{anno_*} functions are used to create annotations for heatmaps.
\code{Heatmap} will be used to create the heatmap.#'
}
\examples{
set.seed(8525)
data <- data.frame(
   F1 = rnorm(100, 0.1),
   F2 = rnorm(100, 0.2),
   F3 = rnorm(100),
   F4 = rnorm(100, 0.3),
   F5 = rnorm(100, -0.1),
   F6 = rnorm(100, -0.2),
   c = sample(letters[1:8], 100, replace = TRUE),
   s = sample(LETTERS[1:2], 100, replace = TRUE),
   p = sample(c("X", "Y", "Z"), 100, replace = TRUE),
   a = sample(1:5, 100, replace = TRUE)
)
rows <- c("F1", "F2", "F3", "F4", "F5", "F6")
rows_data <- data.frame(
   rows = rep(c("F1", "F2", "F3", "F4", "F5", "F6"), each = 10),
   rows1 = rep(c("F1", "F2", "F3", "F4", "F5", "F6"), each = 10),
   rs = rep(letters[1:2], each = 30),
   rp = sample(c("X", "Y", "Z"), 60, replace = TRUE),
   rv = rnorm(60, 0.5)
)

Heatmap(data, rows = rows, columns_by = "c")
Heatmap(data, rows = rows, columns_by = "c", split_by = "s")
Heatmap(data, rows = rows, columns_by = "c", columns_split_by = "s")
Heatmap(data, rows = rows, columns_by = "c", columns_split_by = "s",
        rows_data = rows_data, rows_split_by = "rs")
Heatmap(data, rows = rows, columns_by = "c", columns_split_by = "s",
        rows_data = rows_data, rows_split_by = "rs", flip = TRUE)
Heatmap(data, rows = rows, columns_by = "c", cell_type = "bars")
Heatmap(data, rows = rows, columns_by = "c", cell_type = "bars",
        bars_sample = 3)
Heatmap(data, rows = rows, columns_by = "c", cell_type = "label")
Heatmap(data, rows = rows, columns_by = "c", cell_type = "label",
        label_cutoff = 0)
Heatmap(data, rows = rows, columns_by = "c", cell_type = "dot")
Heatmap(data, rows = rows, columns_by = "c", cell_type = "dot",
        dot_size = mean)
Heatmap(data, rows = rows, columns_by = "c", cell_type = "dot",
        dot_size = mean, add_bg = TRUE)
Heatmap(data, rows = rows, columns_by = "c", cell_type = "dot",
        dot_size = mean, add_reticle = TRUE)
Heatmap(data, rows = rows, columns_by = "c", cell_type = "violin")
Heatmap(data, rows = rows, columns_by = "c", cell_type = "boxplot")
Heatmap(data, rows = rows, columns_by = "c", rows_data = rows_data,
  column_annotation = list(p1 = "p", p2 = "p", F1 = "F1"),
  column_annotation_type = list(p1 = "ring", p2 = "bar", F1 = "violin"),
  column_annotation_params = list(
     p1 = list(height = grid::unit(10, "mm"), show_legend = FALSE),
     F1 = list(height = grid::unit(18, "mm"))),
  rows_split_by = "rs",
  row_annotation = c("rp", "rv", "rows1"),
  row_annotation_side = "right",
  row_annotation_type = list(rp = "pie", rv = "density", rows1 = "simple"),
  row_annotation_params = list(rp = list(width = grid::unit(12, "mm"))),
  show_row_names = TRUE, show_column_names = TRUE)
Heatmap(data, rows = rows, columns_by = "c", rows_data = rows_data,
  column_annotation = list(p1 = "p", p2 = "p", F1 = "F1"),
  column_annotation_type = list(p1 = "ring", p2 = "bar", F1 = "violin"),
  column_annotation_params = list(
     p1 = list(height = grid::unit(10, "mm"), show_legend = FALSE),
     F1 = list(height = grid::unit(18, "mm"))),
  rows_split_by = "rs",
  row_annotation = c("rp", "rv", "rows1"),
  row_annotation_side = "right",
  row_annotation_type = list(rp = "pie", rv = "density", rows1 = "simple"),
  row_annotation_params = list(rp = list(width = grid::unit(12, "mm"))),
  show_row_names = TRUE, show_column_names = TRUE, flip = TRUE)
}
